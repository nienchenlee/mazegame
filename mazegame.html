<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éš¨æ©Ÿè¿·å®®ç”Ÿæˆèˆ‡å°‹è·¯</title>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-generate {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-solve {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }

        .btn-solve:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .btn-clear {
            background: linear-gradient(45deg, #a8e6cf, #7fcdcd);
        }

        .btn-clear:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(168, 230, 207, 0.4);
        }

        .maze-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        canvas {
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .info {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 14px;
        }

        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® éš¨æ©Ÿè¿·å®®ç”Ÿæˆèˆ‡å°‹è·¯</h1>
        
        <div class="controls">
            <button class="btn-generate" onclick="generateMaze()">ç”Ÿæˆæ–°è¿·å®®</button>
            <button class="btn-solve" onclick="solveMaze()">é–‹å§‹å°‹è·¯</button>
            <button class="btn-clear" onclick="clearPath()">æ¸…é™¤è·¯å¾‘</button>
        </div>

        <div class="status" id="status">é»æ“Šã€Œç”Ÿæˆæ–°è¿·å®®ã€é–‹å§‹éŠæˆ²</div>

        <div class="maze-container">
            <canvas id="mazeCanvas" width="600" height="600"></canvas>
        </div>

        <div class="info">
            <p>ğŸ”´ ç´…è‰²ï¼šèµ·é» | ğŸŸ¢ ç¶ è‰²ï¼šçµ‚é» | ğŸ”µ è—è‰²ï¼šå°‹è·¯éç¨‹ | âšª ç™½è‰²ï¼šé€šé“ | âš« æ·±è‰²ï¼šç‰†å£</p>
            <p>ğŸ’¡ æç¤ºï¼šè¿·å®®ä½¿ç”¨éæ­¸å›æº¯ç®—æ³•ç”Ÿæˆï¼Œå°‹è·¯ä½¿ç”¨A*ç®—æ³•</p>
        </div>
    </div>

    <script>
        class Maze {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cellSize = 20;
                this.canvas = document.getElementById('mazeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.maze = [];
                this.start = { x: 1, y: 1 };
                this.end = { x: width - 2, y: height - 2 };
                this.path = [];
                this.visited = [];
                this.isGenerating = false;
                this.isSolving = false;
            }

            // åˆå§‹åŒ–è¿·å®®ï¼ˆå…¨éƒ¨ç‚ºç‰†å£ï¼‰
            initializeMaze() {
                this.maze = [];
                for (let y = 0; y < this.height; y++) {
                    this.maze[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        this.maze[y][x] = 1; // 1 = ç‰†å£, 0 = é€šé“
                    }
                }
            }

            // éæ­¸å›æº¯æ³•ç”Ÿæˆè¿·å®®
            generateMaze() {
                this.initializeMaze();
                this.isGenerating = true;
                this.updateStatus('æ­£åœ¨ç”Ÿæˆè¿·å®®...');
                
                // ä½¿ç”¨éæ­¸å›æº¯ç®—æ³•
                this.carvePassage(1, 1);
                
                // ç¢ºä¿èµ·é»å’Œçµ‚é»æ˜¯é€šé“
                this.maze[this.start.y][this.start.x] = 0;
                this.maze[this.end.y][this.end.x] = 0;
                
                this.isGenerating = false;
                this.updateStatus('è¿·å®®ç”Ÿæˆå®Œæˆï¼é»æ“Šã€Œé–‹å§‹å°‹è·¯ã€å°‹æ‰¾è·¯å¾‘');
                this.debugMaze(); // èª¿è©¦ä¿¡æ¯
                this.drawMaze();
            }

            // éæ­¸å›æº¯æ ¸å¿ƒç®—æ³•
            carvePassage(x, y) {
                this.maze[y][x] = 0; // æ¨™è¨˜ç‚ºé€šé“
                
                // éš¨æ©Ÿæ‰“äº‚æ–¹å‘é †åº
                const directions = [
                    { dx: 0, dy: -2 }, // ä¸Š
                    { dx: 2, dy: 0 },  // å³
                    { dx: 0, dy: 2 },  // ä¸‹
                    { dx: -2, dy: 0 }  // å·¦
                ];
                
                // Fisher-Yates æ´—ç‰Œç®—æ³•
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                // å˜—è©¦æ¯å€‹æ–¹å‘
                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    
                    // æª¢æŸ¥é‚Šç•Œå’Œæ˜¯å¦å·²è¨ªå•
                    if (nx > 0 && nx < this.width - 1 && 
                        ny > 0 && ny < this.height - 1 && 
                        this.maze[ny][nx] === 1) {
                        
                        // æ‰“é€šç‰†å£
                        this.maze[y + dir.dy / 2][x + dir.dx / 2] = 0;
                        
                        // éæ­¸
                        this.carvePassage(nx, ny);
                    }
                }
            }

            // A* å°‹è·¯ç®—æ³•
            async solveMaze() {
                if (this.isGenerating) {
                    this.updateStatus('è«‹ç­‰å¾…è¿·å®®ç”Ÿæˆå®Œæˆ');
                    return;
                }
                
                if (this.isSolving) {
                    this.updateStatus('å°‹è·¯æ­£åœ¨é€²è¡Œä¸­...');
                    return;
                }
                
                this.isSolving = true;
                this.path = [];
                this.visited = [];
                this.updateStatus('æ­£åœ¨å°‹æ‰¾è·¯å¾‘...');
                
                const openSet = [];
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();
                
                // åˆå§‹åŒ–èµ·é»
                const startKey = `${this.start.x},${this.start.y}`;
                openSet.push(this.start);
                gScore.set(startKey, 0);
                fScore.set(startKey, this.heuristic(this.start, this.end));
                
                while (openSet.length > 0) {
                    // æ‰¾åˆ°fåˆ†æ•¸æœ€å°çš„ç¯€é»
                    let current = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        const currentKey = `${current.x},${current.y}`;
                        const nodeKey = `${openSet[i].x},${openSet[i].y}`;
                        if (fScore.get(nodeKey) < fScore.get(currentKey)) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }
                    
                    // å¾é–‹æ”¾é›†åˆä¸­ç§»é™¤ç•¶å‰ç¯€é»
                    openSet.splice(currentIndex, 1);
                    const currentKey = `${current.x},${current.y}`;
                    closedSet.add(currentKey);
                    this.visited.push({...current});
                    
                    // å¯è¦–åŒ–å°‹è·¯éç¨‹
                    this.drawMaze();
                    await this.sleep(50);
                    
                    // æª¢æŸ¥æ˜¯å¦åˆ°é”çµ‚é»
                    if (current.x === this.end.x && current.y === this.end.y) {
                        this.reconstructPath(cameFrom, current);
                        this.isSolving = false;
                        this.updateStatus(`æ‰¾åˆ°è·¯å¾‘ï¼è·¯å¾‘é•·åº¦ï¼š${this.path.length} æ­¥`);
                        this.drawMaze();
                        return;
                    }
                    
                    // æª¢æŸ¥é„°å±…
                    const neighbors = this.getNeighbors(current);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        
                        if (closedSet.has(neighborKey)) continue;
                        
                        const tentativeGScore = gScore.get(currentKey) + 1;
                        
                        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openSet.push(neighbor);
                        } else if (tentativeGScore >= (gScore.get(neighborKey) || Infinity)) {
                            continue;
                        }
                        
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor, this.end));
                    }
                }
                
                this.isSolving = false;
                this.updateStatus('æœªæ‰¾åˆ°è·¯å¾‘ï¼');
            }

            // é‡å»ºè·¯å¾‘
            reconstructPath(cameFrom, current) {
                this.path = [current];
                let currentKey = `${current.x},${current.y}`;
                
                while (cameFrom.has(currentKey)) {
                    current = cameFrom.get(currentKey);
                    this.path.unshift(current);
                    currentKey = `${current.x},${current.y}`;
                }
            }

            // å•Ÿç™¼å¼å‡½æ•¸ï¼ˆæ›¼å“ˆé “è·é›¢ï¼‰
            heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            // ç²å–é„°å±…ç¯€é»
            getNeighbors(node) {
                const neighbors = [];
                const directions = [
                    { dx: 0, dy: -1 }, // ä¸Š
                    { dx: 1, dy: 0 },  // å³
                    { dx: 0, dy: 1 },  // ä¸‹
                    { dx: -1, dy: 0 }  // å·¦
                ];
                
                for (const dir of directions) {
                    const x = node.x + dir.dx;
                    const y = node.y + dir.dy;
                    
                    if (x >= 0 && x < this.width && 
                        y >= 0 && y < this.height && 
                        this.maze[y][x] === 0) {
                        neighbors.push({ x, y });
                    }
                }
                
                return neighbors;
            }

            // ç¹ªè£½è¿·å®®
            drawMaze() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç¹ªè£½è¿·å®®
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const cellX = x * this.cellSize;
                        const cellY = y * this.cellSize;
                        
                        if (this.maze[y][x] === 1) {
                            // ç‰†å£
                            this.ctx.fillStyle = '#2c3e50';
                            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                        } else {
                            // é€šé“
                            this.ctx.fillStyle = '#ecf0f1';
                            this.ctx.fillRect(cellX, cellY, this.cellSize, this.cellSize);
                        }
                    }
                }
                
                // ç¹ªè£½è¨ªå•éçš„ç¯€é»
                this.ctx.fillStyle = '#3498db';
                for (const node of this.visited) {
                    const cellX = node.x * this.cellSize;
                    const cellY = node.y * this.cellSize;
                    this.ctx.fillRect(cellX + 2, cellY + 2, this.cellSize - 4, this.cellSize - 4);
                }
                
                // ç¹ªè£½è·¯å¾‘
                this.ctx.fillStyle = '#e74c3c';
                for (const node of this.path) {
                    const cellX = node.x * this.cellSize;
                    const cellY = node.y * this.cellSize;
                    this.ctx.fillRect(cellX + 4, cellY + 4, this.cellSize - 8, this.cellSize - 8);
                }
                
                // ç¹ªè£½èµ·é»
                this.ctx.fillStyle = '#e74c3c';
                const startX = this.start.x * this.cellSize;
                const startY = this.start.y * this.cellSize;
                this.ctx.beginPath();
                this.ctx.arc(startX + this.cellSize / 2, startY + this.cellSize / 2, this.cellSize / 3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // ç¹ªè£½çµ‚é»
                this.ctx.fillStyle = '#27ae60';
                const endX = this.end.x * this.cellSize;
                const endY = this.end.y * this.cellSize;
                this.ctx.beginPath();
                this.ctx.arc(endX + this.cellSize / 2, endY + this.cellSize / 2, this.cellSize / 3, 0, 2 * Math.PI);
                this.ctx.fill();
            }

            // æ¸…é™¤è·¯å¾‘
            clearPath() {
                this.path = [];
                this.visited = [];
                this.updateStatus('è·¯å¾‘å·²æ¸…é™¤');
                this.drawMaze();
            }

            // æ›´æ–°ç‹€æ…‹
            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }

            // å»¶é²å‡½æ•¸
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // èª¿è©¦ï¼šæª¢æŸ¥è¿·å®®é€£é€šæ€§
            debugMaze() {
                console.log('è¿·å®®å°ºå¯¸:', this.width, 'x', this.height);
                console.log('èµ·é»:', this.start);
                console.log('çµ‚é»:', this.end);
                console.log('èµ·é»æ˜¯å¦ç‚ºé€šé“:', this.maze[this.start.y][this.start.x] === 0);
                console.log('çµ‚é»æ˜¯å¦ç‚ºé€šé“:', this.maze[this.end.y][this.end.x] === 0);
                
                // è¨ˆç®—é€šé“æ•¸é‡
                let pathCount = 0;
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.maze[y][x] === 0) pathCount++;
                    }
                }
                console.log('é€šé“æ•¸é‡:', pathCount);
            }
        }

        // å‰µå»ºè¿·å®®å¯¦ä¾‹
        const maze = new Maze(29, 29); // å¥‡æ•¸å°ºå¯¸ç¢ºä¿æœ‰é‚Šç•Œ

        // å…¨å±€å‡½æ•¸
        function generateMaze() {
            maze.generateMaze();
        }

        function solveMaze() {
            maze.solveMaze();
        }

        function clearPath() {
            maze.clearPath();
        }

        // é é¢åŠ è¼‰å®Œæˆå¾Œè‡ªå‹•ç”Ÿæˆç¬¬ä¸€å€‹è¿·å®®
        window.addEventListener('load', () => {
            generateMaze();
        });
    </script>
</body>
</html>
